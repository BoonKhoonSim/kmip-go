// Code generated by kmipgen; DO NOT EDIT.
package kmip20

import (
	"fmt"
	"github.com/gemalto/kmip-go/ttlv"
	"sort"
	"strings"
)

const (
	TagAdjustmentValue                    ttlv.Tag = 0x066942
	TagAttributes                         ttlv.Tag = 0x420125
	TagCommonAttributes                   ttlv.Tag = 0x420126
	TagPrivateKeyAttributes               ttlv.Tag = 0x420127
	TagPublicKeyAttributes                ttlv.Tag = 0x420128
	TagExtensionEnumeration               ttlv.Tag = 0x420129
	TagExtensionAttribute                 ttlv.Tag = 0x42012a
	TagExtensionParentStructureTag        ttlv.Tag = 0x42012b
	TagExtensionDescription               ttlv.Tag = 0x42012c
	TagServerName                         ttlv.Tag = 0x42012d
	TagServerSerialNumber                 ttlv.Tag = 0x42012e
	TagServerVersion                      ttlv.Tag = 0x42012f
	TagServerLoad                         ttlv.Tag = 0x420130
	TagProductName                        ttlv.Tag = 0x420131
	TagBuildLevel                         ttlv.Tag = 0x420132
	TagBuildDate                          ttlv.Tag = 0x420133
	TagClusterInfo                        ttlv.Tag = 0x420134
	TagAlternateFailoverEndpoints         ttlv.Tag = 0x420135
	TagShortUniqueIdentifier              ttlv.Tag = 0x420136
	TagReserved                           ttlv.Tag = 0x420137
	TagTag                                ttlv.Tag = 0x420138
	TagCertificateRequestUniqueIdentifier ttlv.Tag = 0x420139
	TagNISTKeyType                        ttlv.Tag = 0x42013a
	TagAttributeReference                 ttlv.Tag = 0x42013b
	TagCurrentAttribute                   ttlv.Tag = 0x42013c
	TagNewAttribute                       ttlv.Tag = 0x42013d
	TagCertificateRequestValue            ttlv.Tag = 0x420140
	TagLogMessage                         ttlv.Tag = 0x420141
	TagProfileVersion                     ttlv.Tag = 0x420142
	TagProfileVersionMajor                ttlv.Tag = 0x420143
	TagProfileVersionMinor                ttlv.Tag = 0x420144
	TagProtectionLevel                    ttlv.Tag = 0x420145
	TagProtectionPeriod                   ttlv.Tag = 0x420146
	TagQuantumSafe                        ttlv.Tag = 0x420147
	TagQuantumSafeCapability              ttlv.Tag = 0x420148
	TagTicket                             ttlv.Tag = 0x420149
	TagTicketType                         ttlv.Tag = 0x42014a
	TagTicketValue                        ttlv.Tag = 0x42014b
	TagRequestCount                       ttlv.Tag = 0x42014c
	TagRights                             ttlv.Tag = 0x42014d
	TagObjects                            ttlv.Tag = 0x42014e
	TagOperations                         ttlv.Tag = 0x42014f
	TagRight                              ttlv.Tag = 0x420150
	TagEndpointRole                       ttlv.Tag = 0x420151
	TagDefaultsInformation                ttlv.Tag = 0x420152
	TagObjectDefaults                     ttlv.Tag = 0x420153
	TagEphemeral                          ttlv.Tag = 0x420154
	TagServerHashedPassword               ttlv.Tag = 0x420155
	TagOneTimePassword                    ttlv.Tag = 0x420156
	TagHashedPassword                     ttlv.Tag = 0x420157
	TagAdjustmentType                     ttlv.Tag = 0x420158
	TagPKCS_11Interface                   ttlv.Tag = 0x420159
	TagPKCS_11Function                    ttlv.Tag = 0x42015a
	TagPKCS_11InputParameters             ttlv.Tag = 0x42015b
	TagPKCS_11OutputParameters            ttlv.Tag = 0x42015c
	TagPKCS_11ReturnCode                  ttlv.Tag = 0x42015d
	TagProtectionStorageMask              ttlv.Tag = 0x42015e
	TagProtectionStorageMasks             ttlv.Tag = 0x42015f
	TagInteropFunction                    ttlv.Tag = 0x420160
	TagInteropIdentifier                  ttlv.Tag = 0x420161
)

func init() {
	ttlv.RegisterTag(ttlv.Tag(0x066942), "Adjustment Value")
	ttlv.RegisterTag(ttlv.Tag(0x420125), "Attributes")
	ttlv.RegisterTag(ttlv.Tag(0x420126), "Common Attributes")
	ttlv.RegisterTag(ttlv.Tag(0x420127), "Private Key Attributes")
	ttlv.RegisterTag(ttlv.Tag(0x420128), "Public Key Attributes")
	ttlv.RegisterTag(ttlv.Tag(0x420129), "Extension Enumeration")
	ttlv.RegisterTag(ttlv.Tag(0x42012a), "Extension Attribute")
	ttlv.RegisterTag(ttlv.Tag(0x42012b), "Extension Parent Structure Tag")
	ttlv.RegisterTag(ttlv.Tag(0x42012c), "Extension Description")
	ttlv.RegisterTag(ttlv.Tag(0x42012d), "Server Name")
	ttlv.RegisterTag(ttlv.Tag(0x42012e), "Server Serial Number")
	ttlv.RegisterTag(ttlv.Tag(0x42012f), "Server Version")
	ttlv.RegisterTag(ttlv.Tag(0x420130), "Server Load")
	ttlv.RegisterTag(ttlv.Tag(0x420131), "Product Name")
	ttlv.RegisterTag(ttlv.Tag(0x420132), "Build Level")
	ttlv.RegisterTag(ttlv.Tag(0x420133), "Build Date")
	ttlv.RegisterTag(ttlv.Tag(0x420134), "Cluster Info")
	ttlv.RegisterTag(ttlv.Tag(0x420135), "Alternate Failover Endpoints")
	ttlv.RegisterTag(ttlv.Tag(0x420136), "Short Unique Identifier")
	ttlv.RegisterTag(ttlv.Tag(0x420137), "Reserved")
	ttlv.RegisterTag(ttlv.Tag(0x420138), "Tag")
	ttlv.RegisterTag(ttlv.Tag(0x420139), "Certificate Request Unique Identifier")
	ttlv.RegisterTag(ttlv.Tag(0x42013a), "NIST Key Type")
	ttlv.RegisterTag(ttlv.Tag(0x42013b), "Attribute Reference")
	ttlv.RegisterTag(ttlv.Tag(0x42013c), "Current Attribute")
	ttlv.RegisterTag(ttlv.Tag(0x42013d), "New Attribute")
	ttlv.RegisterTag(ttlv.Tag(0x420140), "Certificate Request Value")
	ttlv.RegisterTag(ttlv.Tag(0x420141), "Log Message")
	ttlv.RegisterTag(ttlv.Tag(0x420142), "Profile Version")
	ttlv.RegisterTag(ttlv.Tag(0x420143), "Profile Version Major")
	ttlv.RegisterTag(ttlv.Tag(0x420144), "Profile Version Minor")
	ttlv.RegisterTag(ttlv.Tag(0x420145), "Protection Level")
	ttlv.RegisterTag(ttlv.Tag(0x420146), "Protection Period")
	ttlv.RegisterTag(ttlv.Tag(0x420147), "Quantum Safe")
	ttlv.RegisterTag(ttlv.Tag(0x420148), "Quantum Safe Capability")
	ttlv.RegisterTag(ttlv.Tag(0x420149), "Ticket")
	ttlv.RegisterTag(ttlv.Tag(0x42014a), "Ticket Type")
	ttlv.RegisterTag(ttlv.Tag(0x42014b), "Ticket Value")
	ttlv.RegisterTag(ttlv.Tag(0x42014c), "Request Count")
	ttlv.RegisterTag(ttlv.Tag(0x42014d), "Rights")
	ttlv.RegisterTag(ttlv.Tag(0x42014e), "Objects")
	ttlv.RegisterTag(ttlv.Tag(0x42014f), "Operations")
	ttlv.RegisterTag(ttlv.Tag(0x420150), "Right")
	ttlv.RegisterTag(ttlv.Tag(0x420151), "Endpoint Role")
	ttlv.RegisterTag(ttlv.Tag(0x420152), "Defaults Information")
	ttlv.RegisterTag(ttlv.Tag(0x420153), "Object Defaults")
	ttlv.RegisterTag(ttlv.Tag(0x420154), "Ephemeral")
	ttlv.RegisterTag(ttlv.Tag(0x420155), "Server Hashed Password")
	ttlv.RegisterTag(ttlv.Tag(0x420156), "One Time Password")
	ttlv.RegisterTag(ttlv.Tag(0x420157), "Hashed Password")
	ttlv.RegisterTag(ttlv.Tag(0x420158), "Adjustment Type")
	ttlv.RegisterTag(ttlv.Tag(0x420159), "PKCS#11 Interface")
	ttlv.RegisterTag(ttlv.Tag(0x42015a), "PKCS#11 Function")
	ttlv.RegisterTag(ttlv.Tag(0x42015b), "PKCS#11 Input Parameters")
	ttlv.RegisterTag(ttlv.Tag(0x42015c), "PKCS#11 Output Parameters")
	ttlv.RegisterTag(ttlv.Tag(0x42015d), "PKCS#11 Return Code")
	ttlv.RegisterTag(ttlv.Tag(0x42015e), "Protection Storage Mask")
	ttlv.RegisterTag(ttlv.Tag(0x42015f), "Protection Storage Masks")
	ttlv.RegisterTag(ttlv.Tag(0x420160), "Interop Function")
	ttlv.RegisterTag(ttlv.Tag(0x420161), "Interop Identifier")
}

// Adjustment Type Enumeration

// 11.1
type AdjustmentType uint32

const (
	AdjustmentTypeIncrement AdjustmentType = 0x00000001
	AdjustmentTypeDecrement AdjustmentType = 0x00000002
	AdjustmentTypeNegate    AdjustmentType = 0x00000003
)

var _AdjustmentTypeNameToValueMap = map[string]AdjustmentType{
	"Increment": AdjustmentTypeIncrement,
	"Decrement": AdjustmentTypeDecrement,
	"Negate":    AdjustmentTypeNegate,
}

var _AdjustmentTypeValueToNameMap = map[AdjustmentType]string{
	AdjustmentTypeIncrement: "Increment",
	AdjustmentTypeDecrement: "Decrement",
	AdjustmentTypeNegate:    "Negate",
}

func (a AdjustmentType) MarshalText() (text []byte, err error) {
	return []byte(a.String()), nil
}

func init() {
	var tag ttlv.Tag
	var err error

	tag, err = ttlv.ParseTag("AdjustmentType")
	if err != nil {
		panic(err)
	}
	ttlv.RegisterEnum(tag, ttlv.EnumTypeDef{
		Parse: func(s string) (uint32, bool) {
			v, ok := _AdjustmentTypeNameToValueMap[s]
			return uint32(v), ok
		},
		String: func(v uint32) string {
			return AdjustmentType(v).String()
		},
		Typed: func(v uint32) interface{} {
			return AdjustmentType(v)
		},
	})
}

func (a AdjustmentType) MarshalTTLV(enc *ttlv.Encoder, tag ttlv.Tag) error {
	enc.EncodeEnumeration(tag, uint32(a))
	return nil
}

func RegisterAdjustmentType(a AdjustmentType, name string) {
	name = ttlv.NormalizeName(name)
	_AdjustmentTypeNameToValueMap[name] = a
	_AdjustmentTypeValueToNameMap[a] = name
}

func (a AdjustmentType) String() string {
	if s, ok := _AdjustmentTypeValueToNameMap[a]; ok {
		return s
	}
	return fmt.Sprintf("%#08x", uint32(a))
}

// Asynchronous Indicator Enumeration

// 11.3
type AsynchronousIndicator uint32

const (
	AsynchronousIndicatorMandatory  AsynchronousIndicator = 0x00000001
	AsynchronousIndicatorOptional   AsynchronousIndicator = 0x00000002
	AsynchronousIndicatorProhibited AsynchronousIndicator = 0x00000003
)

var _AsynchronousIndicatorNameToValueMap = map[string]AsynchronousIndicator{
	"Mandatory":  AsynchronousIndicatorMandatory,
	"Optional":   AsynchronousIndicatorOptional,
	"Prohibited": AsynchronousIndicatorProhibited,
}

var _AsynchronousIndicatorValueToNameMap = map[AsynchronousIndicator]string{
	AsynchronousIndicatorMandatory:  "Mandatory",
	AsynchronousIndicatorOptional:   "Optional",
	AsynchronousIndicatorProhibited: "Prohibited",
}

func (a AsynchronousIndicator) MarshalText() (text []byte, err error) {
	return []byte(a.String()), nil
}

func init() {
	var tag ttlv.Tag
	var err error

	tag, err = ttlv.ParseTag("AsynchronousIndicator")
	if err != nil {
		panic(err)
	}
	ttlv.RegisterEnum(tag, ttlv.EnumTypeDef{
		Parse: func(s string) (uint32, bool) {
			v, ok := _AsynchronousIndicatorNameToValueMap[s]
			return uint32(v), ok
		},
		String: func(v uint32) string {
			return AsynchronousIndicator(v).String()
		},
		Typed: func(v uint32) interface{} {
			return AsynchronousIndicator(v)
		},
	})
}

func (a AsynchronousIndicator) MarshalTTLV(enc *ttlv.Encoder, tag ttlv.Tag) error {
	enc.EncodeEnumeration(tag, uint32(a))
	return nil
}

func RegisterAsynchronousIndicator(a AsynchronousIndicator, name string) {
	name = ttlv.NormalizeName(name)
	_AsynchronousIndicatorNameToValueMap[name] = a
	_AsynchronousIndicatorValueToNameMap[a] = name
}

func (a AsynchronousIndicator) String() string {
	if s, ok := _AsynchronousIndicatorValueToNameMap[a]; ok {
		return s
	}
	return fmt.Sprintf("%#08x", uint32(a))
}

// Data Enumeration

// 11.13
type Data uint32

const (
	DataDecrypt           Data = 0x00000001
	DataEncrypt           Data = 0x00000002
	DataHash              Data = 0x00000003
	DataMACMACData        Data = 0x00000004
	DataRNGRetrieve       Data = 0x00000005
	DataSignSignatureData Data = 0x00000006
	DataSignatureVerify   Data = 0x00000007
)

var _DataNameToValueMap = map[string]Data{
	"Decrypt":           DataDecrypt,
	"Encrypt":           DataEncrypt,
	"Hash":              DataHash,
	"MACMACData":        DataMACMACData,
	"RNGRetrieve":       DataRNGRetrieve,
	"SignSignatureData": DataSignSignatureData,
	"SignatureVerify":   DataSignatureVerify,
}

var _DataValueToNameMap = map[Data]string{
	DataDecrypt:           "Decrypt",
	DataEncrypt:           "Encrypt",
	DataHash:              "Hash",
	DataMACMACData:        "MACMACData",
	DataRNGRetrieve:       "RNGRetrieve",
	DataSignSignatureData: "SignSignatureData",
	DataSignatureVerify:   "SignatureVerify",
}

func (d Data) MarshalText() (text []byte, err error) {
	return []byte(d.String()), nil
}

func init() {
	var tag ttlv.Tag
	var err error

	tag, err = ttlv.ParseTag("Data")
	if err != nil {
		panic(err)
	}
	ttlv.RegisterEnum(tag, ttlv.EnumTypeDef{
		Parse: func(s string) (uint32, bool) {
			v, ok := _DataNameToValueMap[s]
			return uint32(v), ok
		},
		String: func(v uint32) string {
			return Data(v).String()
		},
		Typed: func(v uint32) interface{} {
			return Data(v)
		},
	})
}

func (d Data) MarshalTTLV(enc *ttlv.Encoder, tag ttlv.Tag) error {
	enc.EncodeEnumeration(tag, uint32(d))
	return nil
}

func RegisterData(d Data, name string) {
	name = ttlv.NormalizeName(name)
	_DataNameToValueMap[name] = d
	_DataValueToNameMap[d] = name
}

func (d Data) String() string {
	if s, ok := _DataValueToNameMap[d]; ok {
		return s
	}
	return fmt.Sprintf("%#08x", uint32(d))
}

// Endpoint Role Enumeration

// 11.19
type EndpointRole uint32

const (
	EndpointRoleClient EndpointRole = 0x00000001
	EndpointRoleServer EndpointRole = 0x00000002
)

var _EndpointRoleNameToValueMap = map[string]EndpointRole{
	"Client": EndpointRoleClient,
	"Server": EndpointRoleServer,
}

var _EndpointRoleValueToNameMap = map[EndpointRole]string{
	EndpointRoleClient: "Client",
	EndpointRoleServer: "Server",
}

func (e EndpointRole) MarshalText() (text []byte, err error) {
	return []byte(e.String()), nil
}

func init() {
	var tag ttlv.Tag
	var err error

	tag, err = ttlv.ParseTag("EndpointRole")
	if err != nil {
		panic(err)
	}
	ttlv.RegisterEnum(tag, ttlv.EnumTypeDef{
		Parse: func(s string) (uint32, bool) {
			v, ok := _EndpointRoleNameToValueMap[s]
			return uint32(v), ok
		},
		String: func(v uint32) string {
			return EndpointRole(v).String()
		},
		Typed: func(v uint32) interface{} {
			return EndpointRole(v)
		},
	})
}

func (e EndpointRole) MarshalTTLV(enc *ttlv.Encoder, tag ttlv.Tag) error {
	enc.EncodeEnumeration(tag, uint32(e))
	return nil
}

func RegisterEndpointRole(e EndpointRole, name string) {
	name = ttlv.NormalizeName(name)
	_EndpointRoleNameToValueMap[name] = e
	_EndpointRoleValueToNameMap[e] = name
}

func (e EndpointRole) String() string {
	if s, ok := _EndpointRoleValueToNameMap[e]; ok {
		return s
	}
	return fmt.Sprintf("%#08x", uint32(e))
}

// Interop Function Enumeration

// 11.22
type InteropFunction uint32

const (
	InteropFunctionBegin InteropFunction = 0x00000001
	InteropFunctionEnd   InteropFunction = 0x00000002
	InteropFunctionReset InteropFunction = 0x00000003
)

var _InteropFunctionNameToValueMap = map[string]InteropFunction{
	"Begin": InteropFunctionBegin,
	"End":   InteropFunctionEnd,
	"Reset": InteropFunctionReset,
}

var _InteropFunctionValueToNameMap = map[InteropFunction]string{
	InteropFunctionBegin: "Begin",
	InteropFunctionEnd:   "End",
	InteropFunctionReset: "Reset",
}

func (i InteropFunction) MarshalText() (text []byte, err error) {
	return []byte(i.String()), nil
}

func init() {
	var tag ttlv.Tag
	var err error

	tag, err = ttlv.ParseTag("InteropFunction")
	if err != nil {
		panic(err)
	}
	ttlv.RegisterEnum(tag, ttlv.EnumTypeDef{
		Parse: func(s string) (uint32, bool) {
			v, ok := _InteropFunctionNameToValueMap[s]
			return uint32(v), ok
		},
		String: func(v uint32) string {
			return InteropFunction(v).String()
		},
		Typed: func(v uint32) interface{} {
			return InteropFunction(v)
		},
	})
}

func (i InteropFunction) MarshalTTLV(enc *ttlv.Encoder, tag ttlv.Tag) error {
	enc.EncodeEnumeration(tag, uint32(i))
	return nil
}

func RegisterInteropFunction(i InteropFunction, name string) {
	name = ttlv.NormalizeName(name)
	_InteropFunctionNameToValueMap[name] = i
	_InteropFunctionValueToNameMap[i] = name
}

func (i InteropFunction) String() string {
	if s, ok := _InteropFunctionValueToNameMap[i]; ok {
		return s
	}
	return fmt.Sprintf("%#08x", uint32(i))
}

// NIST Key Type Enumeration

//
type NISTKeyType uint32

const (
	NISTKeyTypePrivateSignatureKey                NISTKeyType = 0x00000001
	NISTKeyTypePublicSignatureVerificationKey     NISTKeyType = 0x00000002
	NISTKeyTypeSymmetricAuthenticationKey         NISTKeyType = 0x00000003
	NISTKeyTypePrivateAuthenticationKey           NISTKeyType = 0x00000004
	NISTKeyTypePublicAuthenticationKey            NISTKeyType = 0x00000005
	NISTKeyTypeSymmetricDataEncryptionKey         NISTKeyType = 0x00000006
	NISTKeyTypeSymmetricKeyWrappingKey            NISTKeyType = 0x00000007
	NISTKeyTypeSymmetricRandomNumberGenerationKey NISTKeyType = 0x00000008
	NISTKeyTypeSymmetricMasterKey                 NISTKeyType = 0x00000009
	NISTKeyTypePrivateKeyTransportKey             NISTKeyType = 0x0000000a
	NISTKeyTypePublicKeyTransportKey              NISTKeyType = 0x0000000b
	NISTKeyTypeSymmetricKeyAgreementKey           NISTKeyType = 0x0000000c
	NISTKeyTypePrivateStaticKeyAgreementKey       NISTKeyType = 0x0000000d
	NISTKeyTypePublicStaticKeyAgreementKey        NISTKeyType = 0x0000000e
	NISTKeyTypePrivateEphemeralKeyAgreementKey    NISTKeyType = 0x0000000f
	NISTKeyTypePublicEphemeralKeyAgreementKey     NISTKeyType = 0x00000010
	NISTKeyTypeSymmetricAuthorizationKey          NISTKeyType = 0x00000011
	NISTKeyTypePrivateAuthorizationKey            NISTKeyType = 0x00000012
	NISTKeyTypePublicAuthorizationKey             NISTKeyType = 0x00000013
)

var _NISTKeyTypeNameToValueMap = map[string]NISTKeyType{
	"PrivateSignatureKey":                NISTKeyTypePrivateSignatureKey,
	"PublicSignatureVerificationKey":     NISTKeyTypePublicSignatureVerificationKey,
	"SymmetricAuthenticationKey":         NISTKeyTypeSymmetricAuthenticationKey,
	"PrivateAuthenticationKey":           NISTKeyTypePrivateAuthenticationKey,
	"PublicAuthenticationKey":            NISTKeyTypePublicAuthenticationKey,
	"SymmetricDataEncryptionKey":         NISTKeyTypeSymmetricDataEncryptionKey,
	"SymmetricKeyWrappingKey":            NISTKeyTypeSymmetricKeyWrappingKey,
	"SymmetricRandomNumberGenerationKey": NISTKeyTypeSymmetricRandomNumberGenerationKey,
	"SymmetricMasterKey":                 NISTKeyTypeSymmetricMasterKey,
	"PrivateKeyTransportKey":             NISTKeyTypePrivateKeyTransportKey,
	"PublicKeyTransportKey":              NISTKeyTypePublicKeyTransportKey,
	"SymmetricKeyAgreementKey":           NISTKeyTypeSymmetricKeyAgreementKey,
	"PrivateStaticKeyAgreementKey":       NISTKeyTypePrivateStaticKeyAgreementKey,
	"PublicStaticKeyAgreementKey":        NISTKeyTypePublicStaticKeyAgreementKey,
	"PrivateEphemeralKeyAgreementKey":    NISTKeyTypePrivateEphemeralKeyAgreementKey,
	"PublicEphemeralKeyAgreementKey":     NISTKeyTypePublicEphemeralKeyAgreementKey,
	"SymmetricAuthorizationKey":          NISTKeyTypeSymmetricAuthorizationKey,
	"PrivateAuthorizationKey":            NISTKeyTypePrivateAuthorizationKey,
	"PublicAuthorizationKey":             NISTKeyTypePublicAuthorizationKey,
}

var _NISTKeyTypeValueToNameMap = map[NISTKeyType]string{
	NISTKeyTypePrivateSignatureKey:                "PrivateSignatureKey",
	NISTKeyTypePublicSignatureVerificationKey:     "PublicSignatureVerificationKey",
	NISTKeyTypeSymmetricAuthenticationKey:         "SymmetricAuthenticationKey",
	NISTKeyTypePrivateAuthenticationKey:           "PrivateAuthenticationKey",
	NISTKeyTypePublicAuthenticationKey:            "PublicAuthenticationKey",
	NISTKeyTypeSymmetricDataEncryptionKey:         "SymmetricDataEncryptionKey",
	NISTKeyTypeSymmetricKeyWrappingKey:            "SymmetricKeyWrappingKey",
	NISTKeyTypeSymmetricRandomNumberGenerationKey: "SymmetricRandomNumberGenerationKey",
	NISTKeyTypeSymmetricMasterKey:                 "SymmetricMasterKey",
	NISTKeyTypePrivateKeyTransportKey:             "PrivateKeyTransportKey",
	NISTKeyTypePublicKeyTransportKey:              "PublicKeyTransportKey",
	NISTKeyTypeSymmetricKeyAgreementKey:           "SymmetricKeyAgreementKey",
	NISTKeyTypePrivateStaticKeyAgreementKey:       "PrivateStaticKeyAgreementKey",
	NISTKeyTypePublicStaticKeyAgreementKey:        "PublicStaticKeyAgreementKey",
	NISTKeyTypePrivateEphemeralKeyAgreementKey:    "PrivateEphemeralKeyAgreementKey",
	NISTKeyTypePublicEphemeralKeyAgreementKey:     "PublicEphemeralKeyAgreementKey",
	NISTKeyTypeSymmetricAuthorizationKey:          "SymmetricAuthorizationKey",
	NISTKeyTypePrivateAuthorizationKey:            "PrivateAuthorizationKey",
	NISTKeyTypePublicAuthorizationKey:             "PublicAuthorizationKey",
}

func (n NISTKeyType) MarshalText() (text []byte, err error) {
	return []byte(n.String()), nil
}

func init() {
	var tag ttlv.Tag
	var err error

	tag, err = ttlv.ParseTag("NISTKeyType")
	if err != nil {
		panic(err)
	}
	ttlv.RegisterEnum(tag, ttlv.EnumTypeDef{
		Parse: func(s string) (uint32, bool) {
			v, ok := _NISTKeyTypeNameToValueMap[s]
			return uint32(v), ok
		},
		String: func(v uint32) string {
			return NISTKeyType(v).String()
		},
		Typed: func(v uint32) interface{} {
			return NISTKeyType(v)
		},
	})
}

func (n NISTKeyType) MarshalTTLV(enc *ttlv.Encoder, tag ttlv.Tag) error {
	enc.EncodeEnumeration(tag, uint32(n))
	return nil
}

func RegisterNISTKeyType(n NISTKeyType, name string) {
	name = ttlv.NormalizeName(name)
	_NISTKeyTypeNameToValueMap[name] = n
	_NISTKeyTypeValueToNameMap[n] = name
}

func (n NISTKeyType) String() string {
	if s, ok := _NISTKeyTypeValueToNameMap[n]; ok {
		return s
	}
	return fmt.Sprintf("%#08x", uint32(n))
}

// PKCS#11 Function Enumeration

//
type PKCS_11Function uint32

const ()

var _PKCS_11FunctionNameToValueMap = map[string]PKCS_11Function{}

var _PKCS_11FunctionValueToNameMap = map[PKCS_11Function]string{}

func (p PKCS_11Function) MarshalText() (text []byte, err error) {
	return []byte(p.String()), nil
}

func init() {
	var tag ttlv.Tag
	var err error

	tag, err = ttlv.ParseTag("PKCS_11Function")
	if err != nil {
		panic(err)
	}
	ttlv.RegisterEnum(tag, ttlv.EnumTypeDef{
		Parse: func(s string) (uint32, bool) {
			v, ok := _PKCS_11FunctionNameToValueMap[s]
			return uint32(v), ok
		},
		String: func(v uint32) string {
			return PKCS_11Function(v).String()
		},
		Typed: func(v uint32) interface{} {
			return PKCS_11Function(v)
		},
	})
}

func (p PKCS_11Function) MarshalTTLV(enc *ttlv.Encoder, tag ttlv.Tag) error {
	enc.EncodeEnumeration(tag, uint32(p))
	return nil
}

func RegisterPKCS_11Function(p PKCS_11Function, name string) {
	name = ttlv.NormalizeName(name)
	_PKCS_11FunctionNameToValueMap[name] = p
	_PKCS_11FunctionValueToNameMap[p] = name
}

func (p PKCS_11Function) String() string {
	if s, ok := _PKCS_11FunctionValueToNameMap[p]; ok {
		return s
	}
	return fmt.Sprintf("%#08x", uint32(p))
}

// PKCS#11 Return Code Enumeration

//
type PKCS_11ReturnCode uint32

const ()

var _PKCS_11ReturnCodeNameToValueMap = map[string]PKCS_11ReturnCode{}

var _PKCS_11ReturnCodeValueToNameMap = map[PKCS_11ReturnCode]string{}

func (p PKCS_11ReturnCode) MarshalText() (text []byte, err error) {
	return []byte(p.String()), nil
}

func init() {
	var tag ttlv.Tag
	var err error

	tag, err = ttlv.ParseTag("PKCS_11ReturnCode")
	if err != nil {
		panic(err)
	}
	ttlv.RegisterEnum(tag, ttlv.EnumTypeDef{
		Parse: func(s string) (uint32, bool) {
			v, ok := _PKCS_11ReturnCodeNameToValueMap[s]
			return uint32(v), ok
		},
		String: func(v uint32) string {
			return PKCS_11ReturnCode(v).String()
		},
		Typed: func(v uint32) interface{} {
			return PKCS_11ReturnCode(v)
		},
	})
}

func (p PKCS_11ReturnCode) MarshalTTLV(enc *ttlv.Encoder, tag ttlv.Tag) error {
	enc.EncodeEnumeration(tag, uint32(p))
	return nil
}

func RegisterPKCS_11ReturnCode(p PKCS_11ReturnCode, name string) {
	name = ttlv.NormalizeName(name)
	_PKCS_11ReturnCodeNameToValueMap[name] = p
	_PKCS_11ReturnCodeValueToNameMap[p] = name
}

func (p PKCS_11ReturnCode) String() string {
	if s, ok := _PKCS_11ReturnCodeValueToNameMap[p]; ok {
		return s
	}
	return fmt.Sprintf("%#08x", uint32(p))
}

// Protection Level Enumeration

//
type ProtectionLevel uint32

const (
	ProtectionLevelHigh ProtectionLevel = 0x00000001
	ProtectionLevelLow  ProtectionLevel = 0x00000002
)

var _ProtectionLevelNameToValueMap = map[string]ProtectionLevel{
	"High": ProtectionLevelHigh,
	"Low":  ProtectionLevelLow,
}

var _ProtectionLevelValueToNameMap = map[ProtectionLevel]string{
	ProtectionLevelHigh: "High",
	ProtectionLevelLow:  "Low",
}

func (p ProtectionLevel) MarshalText() (text []byte, err error) {
	return []byte(p.String()), nil
}

func init() {
	var tag ttlv.Tag
	var err error

	tag, err = ttlv.ParseTag("ProtectionLevel")
	if err != nil {
		panic(err)
	}
	ttlv.RegisterEnum(tag, ttlv.EnumTypeDef{
		Parse: func(s string) (uint32, bool) {
			v, ok := _ProtectionLevelNameToValueMap[s]
			return uint32(v), ok
		},
		String: func(v uint32) string {
			return ProtectionLevel(v).String()
		},
		Typed: func(v uint32) interface{} {
			return ProtectionLevel(v)
		},
	})
}

func (p ProtectionLevel) MarshalTTLV(enc *ttlv.Encoder, tag ttlv.Tag) error {
	enc.EncodeEnumeration(tag, uint32(p))
	return nil
}

func RegisterProtectionLevel(p ProtectionLevel, name string) {
	name = ttlv.NormalizeName(name)
	_ProtectionLevelNameToValueMap[name] = p
	_ProtectionLevelValueToNameMap[p] = name
}

func (p ProtectionLevel) String() string {
	if s, ok := _ProtectionLevelValueToNameMap[p]; ok {
		return s
	}
	return fmt.Sprintf("%#08x", uint32(p))
}

// Ticket Type Enumeration

//
type TicketType uint32

const (
	TicketTypeLogin TicketType = 0x00000001
)

var _TicketTypeNameToValueMap = map[string]TicketType{
	"Login": TicketTypeLogin,
}

var _TicketTypeValueToNameMap = map[TicketType]string{
	TicketTypeLogin: "Login",
}

func (t TicketType) MarshalText() (text []byte, err error) {
	return []byte(t.String()), nil
}

func init() {
	var tag ttlv.Tag
	var err error

	tag, err = ttlv.ParseTag("TicketType")
	if err != nil {
		panic(err)
	}
	ttlv.RegisterEnum(tag, ttlv.EnumTypeDef{
		Parse: func(s string) (uint32, bool) {
			v, ok := _TicketTypeNameToValueMap[s]
			return uint32(v), ok
		},
		String: func(v uint32) string {
			return TicketType(v).String()
		},
		Typed: func(v uint32) interface{} {
			return TicketType(v)
		},
	})
}

func (t TicketType) MarshalTTLV(enc *ttlv.Encoder, tag ttlv.Tag) error {
	enc.EncodeEnumeration(tag, uint32(t))
	return nil
}

func RegisterTicketType(t TicketType, name string) {
	name = ttlv.NormalizeName(name)
	_TicketTypeNameToValueMap[name] = t
	_TicketTypeValueToNameMap[t] = name
}

func (t TicketType) String() string {
	if s, ok := _TicketTypeValueToNameMap[t]; ok {
		return s
	}
	return fmt.Sprintf("%#08x", uint32(t))
}

// Unique Identifier Enumeration

//
type UniqueIdentifier uint32

const (
	UniqueIdentifierIDPlaceholder           UniqueIdentifier = 0x00000001
	UniqueIdentifierCertify                 UniqueIdentifier = 0x00000002
	UniqueIdentifierCreate                  UniqueIdentifier = 0x00000003
	UniqueIdentifierCreateKeyPair           UniqueIdentifier = 0x00000004
	UniqueIdentifierCreateKeyPairPrivateKey UniqueIdentifier = 0x00000005
	UniqueIdentifierCreateKeyPairPublicKey  UniqueIdentifier = 0x00000006
	UniqueIdentifierCreateSplitKey          UniqueIdentifier = 0x00000007
	UniqueIdentifierDeriveKey               UniqueIdentifier = 0x00000008
	UniqueIdentifierImport                  UniqueIdentifier = 0x00000009
	UniqueIdentifierJoinSplitKey            UniqueIdentifier = 0x0000000a
	UniqueIdentifierLocate                  UniqueIdentifier = 0x0000000b
	UniqueIdentifierRegister                UniqueIdentifier = 0x0000000c
	UniqueIdentifierReKey                   UniqueIdentifier = 0x0000000d
	UniqueIdentifierReCertify               UniqueIdentifier = 0x0000000e
	UniqueIdentifierReKeyKeyPair            UniqueIdentifier = 0x0000000f
	UniqueIdentifierReKeyKeyPairPrivateKey  UniqueIdentifier = 0x00000010
	UniqueIdentifierReKeyKeyPairPublicKey   UniqueIdentifier = 0x00000011
)

var _UniqueIdentifierNameToValueMap = map[string]UniqueIdentifier{
	"IDPlaceholder":           UniqueIdentifierIDPlaceholder,
	"Certify":                 UniqueIdentifierCertify,
	"Create":                  UniqueIdentifierCreate,
	"CreateKeyPair":           UniqueIdentifierCreateKeyPair,
	"CreateKeyPairPrivateKey": UniqueIdentifierCreateKeyPairPrivateKey,
	"CreateKeyPairPublicKey":  UniqueIdentifierCreateKeyPairPublicKey,
	"CreateSplitKey":          UniqueIdentifierCreateSplitKey,
	"DeriveKey":               UniqueIdentifierDeriveKey,
	"Import":                  UniqueIdentifierImport,
	"JoinSplitKey":            UniqueIdentifierJoinSplitKey,
	"Locate":                  UniqueIdentifierLocate,
	"Register":                UniqueIdentifierRegister,
	"ReKey":                   UniqueIdentifierReKey,
	"ReCertify":               UniqueIdentifierReCertify,
	"ReKeyKeyPair":            UniqueIdentifierReKeyKeyPair,
	"ReKeyKeyPairPrivateKey":  UniqueIdentifierReKeyKeyPairPrivateKey,
	"ReKeyKeyPairPublicKey":   UniqueIdentifierReKeyKeyPairPublicKey,
}

var _UniqueIdentifierValueToNameMap = map[UniqueIdentifier]string{
	UniqueIdentifierIDPlaceholder:           "IDPlaceholder",
	UniqueIdentifierCertify:                 "Certify",
	UniqueIdentifierCreate:                  "Create",
	UniqueIdentifierCreateKeyPair:           "CreateKeyPair",
	UniqueIdentifierCreateKeyPairPrivateKey: "CreateKeyPairPrivateKey",
	UniqueIdentifierCreateKeyPairPublicKey:  "CreateKeyPairPublicKey",
	UniqueIdentifierCreateSplitKey:          "CreateSplitKey",
	UniqueIdentifierDeriveKey:               "DeriveKey",
	UniqueIdentifierImport:                  "Import",
	UniqueIdentifierJoinSplitKey:            "JoinSplitKey",
	UniqueIdentifierLocate:                  "Locate",
	UniqueIdentifierRegister:                "Register",
	UniqueIdentifierReKey:                   "ReKey",
	UniqueIdentifierReCertify:               "ReCertify",
	UniqueIdentifierReKeyKeyPair:            "ReKeyKeyPair",
	UniqueIdentifierReKeyKeyPairPrivateKey:  "ReKeyKeyPairPrivateKey",
	UniqueIdentifierReKeyKeyPairPublicKey:   "ReKeyKeyPairPublicKey",
}

func (u UniqueIdentifier) MarshalText() (text []byte, err error) {
	return []byte(u.String()), nil
}

func init() {
	var tag ttlv.Tag
	var err error

	tag, err = ttlv.ParseTag("UniqueIdentifier")
	if err != nil {
		panic(err)
	}
	ttlv.RegisterEnum(tag, ttlv.EnumTypeDef{
		Parse: func(s string) (uint32, bool) {
			v, ok := _UniqueIdentifierNameToValueMap[s]
			return uint32(v), ok
		},
		String: func(v uint32) string {
			return UniqueIdentifier(v).String()
		},
		Typed: func(v uint32) interface{} {
			return UniqueIdentifier(v)
		},
	})
	tag, err = ttlv.ParseTag("Link")
	if err != nil {
		panic(err)
	}
	ttlv.RegisterEnum(tag, ttlv.EnumTypeDef{
		Parse: func(s string) (uint32, bool) {
			v, ok := _UniqueIdentifierNameToValueMap[s]
			return uint32(v), ok
		},
		String: func(v uint32) string {
			return UniqueIdentifier(v).String()
		},
		Typed: func(v uint32) interface{} {
			return UniqueIdentifier(v)
		},
	})
}

func (u UniqueIdentifier) MarshalTTLV(enc *ttlv.Encoder, tag ttlv.Tag) error {
	enc.EncodeEnumeration(tag, uint32(u))
	return nil
}

func RegisterUniqueIdentifier(u UniqueIdentifier, name string) {
	name = ttlv.NormalizeName(name)
	_UniqueIdentifierNameToValueMap[name] = u
	_UniqueIdentifierValueToNameMap[u] = name
}

func (u UniqueIdentifier) String() string {
	if s, ok := _UniqueIdentifierValueToNameMap[u]; ok {
		return s
	}
	return fmt.Sprintf("%#08x", uint32(u))
}

// Protection Storage Mask Bit Mask

//
type ProtectionStorageMask uint32

const (
	ProtectionStorageMaskSoftware         ProtectionStorageMask = 0x00000001
	ProtectionStorageMaskHardware         ProtectionStorageMask = 0x00000002
	ProtectionStorageMaskOnProcessor      ProtectionStorageMask = 0x00000004
	ProtectionStorageMaskOnSystem         ProtectionStorageMask = 0x00000008
	ProtectionStorageMaskOffSystem        ProtectionStorageMask = 0x00000010
	ProtectionStorageMaskHypervisor       ProtectionStorageMask = 0x00000020
	ProtectionStorageMaskOperatingSystem  ProtectionStorageMask = 0x00000040
	ProtectionStorageMaskContainer        ProtectionStorageMask = 0x00000080
	ProtectionStorageMaskOnPremises       ProtectionStorageMask = 0x00000100
	ProtectionStorageMaskOffPremises      ProtectionStorageMask = 0x00000200
	ProtectionStorageMaskSelfManaged      ProtectionStorageMask = 0x00000400
	ProtectionStorageMaskOutsourced       ProtectionStorageMask = 0x00000800
	ProtectionStorageMaskValidated        ProtectionStorageMask = 0x00001000
	ProtectionStorageMaskSameJurisdiction ProtectionStorageMask = 0x00002000
)

var _ProtectionStorageMaskNameToValueMap = map[string]ProtectionStorageMask{
	"Software":         ProtectionStorageMaskSoftware,
	"Hardware":         ProtectionStorageMaskHardware,
	"OnProcessor":      ProtectionStorageMaskOnProcessor,
	"OnSystem":         ProtectionStorageMaskOnSystem,
	"OffSystem":        ProtectionStorageMaskOffSystem,
	"Hypervisor":       ProtectionStorageMaskHypervisor,
	"OperatingSystem":  ProtectionStorageMaskOperatingSystem,
	"Container":        ProtectionStorageMaskContainer,
	"OnPremises":       ProtectionStorageMaskOnPremises,
	"OffPremises":      ProtectionStorageMaskOffPremises,
	"SelfManaged":      ProtectionStorageMaskSelfManaged,
	"Outsourced":       ProtectionStorageMaskOutsourced,
	"Validated":        ProtectionStorageMaskValidated,
	"SameJurisdiction": ProtectionStorageMaskSameJurisdiction,
}

var _ProtectionStorageMaskValueToNameMap = map[ProtectionStorageMask]string{
	ProtectionStorageMaskSoftware:         "Software",
	ProtectionStorageMaskHardware:         "Hardware",
	ProtectionStorageMaskOnProcessor:      "OnProcessor",
	ProtectionStorageMaskOnSystem:         "OnSystem",
	ProtectionStorageMaskOffSystem:        "OffSystem",
	ProtectionStorageMaskHypervisor:       "Hypervisor",
	ProtectionStorageMaskOperatingSystem:  "OperatingSystem",
	ProtectionStorageMaskContainer:        "Container",
	ProtectionStorageMaskOnPremises:       "OnPremises",
	ProtectionStorageMaskOffPremises:      "OffPremises",
	ProtectionStorageMaskSelfManaged:      "SelfManaged",
	ProtectionStorageMaskOutsourced:       "Outsourced",
	ProtectionStorageMaskValidated:        "Validated",
	ProtectionStorageMaskSameJurisdiction: "SameJurisdiction",
}

func (p ProtectionStorageMask) MarshalText() (text []byte, err error) {
	return []byte(p.String()), nil
}

func init() {
	var tag ttlv.Tag
	var err error

	tag, err = ttlv.ParseTag("ProtectionStorageMask")
	if err != nil {
		panic(err)
	}
	ttlv.RegisterBitMask(tag, ttlv.EnumTypeDef{
		Parse: func(s string) (uint32, bool) {
			v, ok := _ProtectionStorageMaskNameToValueMap[s]
			return uint32(v), ok
		},
		String: func(v uint32) string {
			return ProtectionStorageMask(v).String()
		},
		Typed: func(v uint32) interface{} {
			return ProtectionStorageMask(v)
		},
	})
}

func RegisterProtectionStorageMask(p ProtectionStorageMask, name string) {
	name = ttlv.NormalizeName(name)
	_ProtectionStorageMaskNameToValueMap[name] = p
	_ProtectionStorageMaskValueToNameMap[p] = name
	_ProtectionStorageMaskSortedValues = append(_ProtectionStorageMaskSortedValues, int(p))
	sort.Ints(_ProtectionStorageMaskSortedValues)
}

var _ProtectionStorageMaskSortedValues []int

func init() {
	for p := range _ProtectionStorageMaskValueToNameMap {
		_ProtectionStorageMaskSortedValues = append(_ProtectionStorageMaskSortedValues, int(p))
		sort.Ints(_ProtectionStorageMaskSortedValues)
	}
}

func (p ProtectionStorageMask) String() string {
	r := int(p)

	var sb strings.Builder
	var appending bool
	for _, v := range _ProtectionStorageMaskSortedValues {
		if v&r == v {
			if name := _ProtectionStorageMaskValueToNameMap[ProtectionStorageMask(v)]; name != "" {
				if appending {
					sb.WriteString("|")
				} else {
					appending = true
				}
				sb.WriteString(name)
				r ^= v
			}

		}
		if r == 0 {
			break
		}
	}
	if r != 0 {
		if appending {
			sb.WriteString("|")
		}
		fmt.Fprintf(&sb, "%#08x", uint32(r))
	}
	return sb.String()
}
